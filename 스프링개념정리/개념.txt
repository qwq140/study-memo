1. controller 동작원리 = request, response
2. 필터 거는 법
3 response 공통적인 Object를 만들어서 응답 - User 오브젝트

탬플릿 엔진을 사용하는 이유
내가 응답하고 있는 것이 파일이기 때문에 파일이라고 알려줌

http://localhost:8080/start/hello requset 요청을 하면 컨트롤러를 메모리에 띄움


개발자가 직접 메모리에 띄우는게 아니라 requset요청시 컴포넌트 스캔하여 해당 컨트롤러를 메모리에 띄우는 것


결합도는 낮추고 응집도는 높힌다.


IoC가 레퍼런스를 관리하고
DI를 통해 레퍼런스에 접근한다.

DI는 생성자에 인수를 주입시켜준다.(IoC에 있는 것만) 

@Component : 특별한 용도가 없는 객체 = 타이밍이 @Controller, @RestController 띄우는 타이밍보다 늦음.
@Configuration : 설정과 관련된 객체 (가장 빠르게 리플렉션 됨)
타이밍 : @Configuration => @RestController or @Controller => @Component
@Configuration에서 필터를 적용시킬수 있다.

DI(의존성주입) - 타입으로 구분하기 때문에 싱글톤으로 관리한다.

빈 생성자가 아닌 인수가 있는 생성자 인 경우 IoC에 인수가 있는지 확인을 하고 없으면 오류가 발생




클라이언트로부터 request 요청을 받으면 디스패처 서블릿이 동작하여 해당 컨트롤러를 메모리에 띄움

IoC는 사용자(클라이언트)마다 있음.
Configuration 하나만 뜨지만 사용자마다 하나 뜸.

사용자 요청시에 컴포넌트 스캔을 한다. 이때 찾는 것은 @Configuration @Component @RestController @Controller @Repository @Service
@Configuration @Component @Repository @Service은 찾자마자 IoC에 집어 넣음  - context
@RestController @Controller는 실행하고 종료함 (디스패처 서블릿이 관리) -servlet 
context가 servlet보다 먼저 실행

web.xml을 다시 타는 것이 아니라 그안의 필터를 다시 타는것이다.
web.xml은 서버시작 시 한번만 탄다.

순차적으로 뜨도록 관리

최초요청 Servlet

Repository : 서버, DB, file
데이터 -- 서버 json, DB rs, file InputStream
1. 파싱을 한다.
2. 자바오브젝트로 바꿔준다.

컨트롤러는 서비스를 요청 서비스는 Repository를 요청

컨트롤러 레이어, 서비스 레이어, 레파지토리 레이어

@Service 서비스 : 기능정의, 트랜잭션 관리의 책임
컨트롤러 : 라우팅, 응답(data로 해줄지 파일로 해줄지) 책임

결합도가 높다 : 의존도가 높다.
응집도가 높다 : 객체끼리 커뮤니케이션이 잘된다.



https://getinthere.tistory.com/11


-----------------------------------------

RestController
기본적인 요청과 응답
validation 체크
로그 남기기
문서로 만들기
CORS

--------------------------
PathVariable : String을 id로 변환


----------------------------
2021.01.15

1. Validation 체크
request 할때 들어오는 쿼리스트링 또는 http body 값들을 필터가 받아서 처리

post: /user   username, password

/user -> 디스패처 -> /user 주소가 있는 함수 찾기
-> 그 함수의 매개변수 확인 -> String username, String password -> 개수 확인
-> 정상

--------------------------------------------------------
스프링 -> 디스패처가 구현되어있음

디스패처가 하는일
1. 주소 매핑
2. IoC @Controller @Rest 메모리에 띄움
3. 함수 매개변수 == request 값
4. 주입

AOP (리플렉션 공부하기)
Aspect Oriented Programing (관점 지향 프로그래밍)
핵심기능 : 회원가입, 유저정보보기 등등 
공통기능 : JoinPoint, PointCut
프록시공간으로 함수를 들고와서 그 함수의 앞뒤를 관리한다.

함수의 앞만 처리하고 싶으면 필터를 사용
함수의 앞뒤를 처리하고 싶으면 AOP를 사용


a함수 시작전 유효성검사
a함수가 응답할 때 응답에 대한 유효성 검사


@Configuration 설정 나머지는 @Component

JoinPoint는 @Around에서만 사용가능


Spring AOP PointCut 표현식
https://icarus8050.tistory.com/8

카운팅 같은거 전처리에서 처리


최종 입구에서 처리는 전처리
각각 함수의 앞뒤 처리는 AOP

로그 레벨 : error, warn, info, debug


bindingResult 문제가 있는 결과들을 다 담아둠
error.getField 어떤필드가 오류났는지

-------------------------------------
Spring5.0(WebFlux-병렬) -> RxJava - ReactivePrograming
->단일스레드, 비동기 -> RDBMS(MySQL, Oracle) 지원x
-> R2DBC (비동기 DB)

Spring(Servlet-스레드기반)
-> 페이지(Servlet) : 일반적인 상황
-> 페이지(webflux-R2DBC-SSE)    :  채팅할때 

/a, /b                              /c
서버1(servlet+웹소켓) + 서버2(webflux+see(프로토콜))
-> 이벤트 드리븐
-> Redis(메모리세션서버) + JWT 토큰방식
이벤트 드리븐 : 데이터가 바뀌었을 때 리퀘스트를 안햇는데도 화면을 다시 불러옴


오준석

AWS자격증 Docker, MSA
----------------------------------------
부트스트랩 모음
https://blog.naver.com/codingspecialist/221449851012

결제라이브러리
https://www.iamport.kr/getstarted

스트링부트 동작원리
https://getinthere.tistory.com/11

sentry.io : 웹으로 로그를 보여줌


1. 수업 복습하기 (실습)
2. 금요일 수업마치기 전까지 화면설계+모델 설명 제출 (참고;오태경자료)
3. 먼저 시작하고 싶으면 화면 부터 만들기
4. 다음주 월요일에 모델 나랑 협의해서 수정하기

git 자료
https://github.com/codingspecialist/Springboot-Jpa-AOP-Valid-RestDoc

https://github.com/codingspecialist/Springboot-Special-Lecture